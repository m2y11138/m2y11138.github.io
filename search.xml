<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2025/10/04/10/</url>
    <content><![CDATA[选择器简单选择器： 全局选择器 ID选择器 类选择器 伪类选择器 属性选择器 元素选择器 伪元素选择器
复合选择器： 相邻兄弟选择器+ 后代选择器 子选择器&gt; 合并选择器 通用兄弟选择器~
符号不计算权重
层叠声明冲突：同一个样式，多次声明到同一个元素
声明冲突是一个现象
层叠：解决声明冲突的过程，浏览器自动处理（权重计算）
1.比较重要性重要性从高到低：  作者样式表中的 !important -&gt; 作者样式表中的普通样式 -&gt; 浏览器默认样式表 
一般不用important，后面要修改只能用更高级的选择器，更靠后的顺序但是都要加 !important 才能覆盖 
2.比较特殊性当相同重要的时候，比较特殊性
看选择器，选择器权重越高，越特殊
算法： 生成一个四位数   从高到低分别是 内联样式记1 id选择器个数  类元素/伪类元素选择器个数 元素选择器/伪元素选择器个数
四位数不能进位
3.比较源次序重要性，特殊性都无法比较
靠后的胜出
4.应用重置样式表，覆盖浏览器默认样式，保证不同浏览器效果不同  直接找重置样式表 reset.css
继承子元素会继承父元素的某些 CSS 属性
通常跟文字，内容相关的属性都会继承
属性值的计算过程一个元素一个元素依次渲染，顺序按照页面文档的树形目录结构计算
渲染元素的前提条件：该元素的所有CSS属性都必须有值
一个元素从所有属性都没有值，到所有属性都计算出来的过程算法，叫做属性值计算过程
过程： 1.确定声明值 收集所有结果 2.使用层叠规则解决冲突 3. 如果属性没有值，属性可以继承，使用继承 4.如果还没有值，使用浏览器默认样式 
最终计算结果在 computed 处查看
浏览器默认样式和浏览器默认声明不一样
强制继承 color: inherit 不能继承的也可以让他强制继承
特殊 CSS 取值 强制继承inherit initial初始值，将该属性设置为默认值
盒模型：每个元素在页面中都会生成一个矩形区域
学习盒子的特点
盒子类型：行盒 display: inline   块盒 display: block
行盒在页面中不换行
块盒独占一行
浏览器默认样式表设置的块盒：容器元素，h1-h6,p
常见的行盒：通常文本元素 span,a, img,video,audio 和内容相关的
盒子的组成部分：
内容 content  width/height 盒子内容的宽高
填充 padding  盒子边框到盒子内容的距离
边框 border  边框样式+边框宽度+边框颜色
外边距 margin 边框到其他盒子的距离
行盒： height/width 无法生效，因为占据空间是根据内容占据的 ，要调整占据空间应该使用字体大小，行高，字体类型间接调整
margin/padding/border: 指定左右的时候都是挤压已有的空间，上下是往外扩展
行，块盒子  display: inline-block   不独占一行，所有尺寸都有效
还有一种指定模式就是 width 就是元素整体的宽度，现在的模式就是 元素整体宽度是 width + 两个padding + 两个 margin + 两个 border
line-height:规定每一行文字垂直占用空间，比font-size大的部分会平均分 如果 line-height 小于总高度，那么多出来的总高度会在 line-height 的下面，因为 line-height 默认从上面开始截取
空白折叠发生在行（块）盒内部或行（块）盒之间：会把之间的空格折叠成一个空格
可替换元素和非可替换元素：大部分元素，页面上现实的结果，取决于元素内容，称为非可替换元素 div,p,span 
少部分元素，页面上显示的结果，取决于元素属性，称为可替换元素  image,video,audio, 默认为行盒
可替换元素类似于行块盒，所有尺寸都有效。理解为行块盒 object-fit: fill/cover/contain
改变宽高范围：默认情况下，width/height是内容的宽高 为了方便设计 测量设计稿   因为不会量内容盒 量边框盒
CSS3： box-sizing: border-box  默认的宽度和高度指的是哪个盒子 设置为边框盒
CSS3  画三角形 clip-path: polygon(50% 0%, 0% 100%, 100% 100%); 实在不行背景图片加载一个 url 三角形
控制内容溢出边框盒的处理方式 overflow: hidden/scroll/auto
隐藏元素 height:0 overflow: hidden  移除隐藏 seo 必须要写 但是又不想显示出来
断词规则： word-break 影响文字在什么位置被截断换行 
空白处理: 显示内容太长了，做截断 white-space:  超出范围是否换行
white-space: nowrap
overflow: hidden
text-overflow: ellipsis
常规流 
盒模型：规定单个盒子的规则
视觉格式化模型（布局规则）：页面中的多个盒子排列规则
常规流, absolute , float, flex, grid
常规流，文档流，普通文档流，常规文档流： 所有元素默认情况下属于常规流布局 
总体规则：块盒独占一行，行盒水平排列
包含块：每个盒子都有它的包含块，包含块决定了盒子的活动范围，大部分情况下，盒子的包含块，是父元素的内容盒
每个块盒的总宽度刚好等于包含块的宽度
宽度默认值是 auto 表示将剩余空间占据
常规流块盒在包含块中居中，定宽 margin: auto
margin 垂直auto 是0
宽度吸收能力大于 margin
height: auto 适应内容的高度
百分比取值 padding,宽，margin 相对于包含块的宽度
上下外边距合并：两个常规流块盒，上下外边距相邻，会进行合并 两个外边距取最大值 兄弟元素 父子元素都要合并
iframe 元素 通常在一个页面中嵌入另一个页面 src表示网页的地址 可替换元素 行块盒 CSS不能完全控制其中的样式
video 是无法拿到的 是可以用 iframe 链接包裹到 配合a做target 使用
flash: object embed  MIME类型格式 多用途互联网邮件类型 互联网中确定不同资源类型
多媒体元素： video视频 audio音频
video src
audio src
视频都有保护 不会让你轻易拿到 一般都是 iframe
某些属性只有两种状态 有/没有 这种属性叫布尔属性 显示播放控件 controls    自动播放autoplay 静音播放muted loop循环播放
音频元素和视频用法完全一致
兼容性 旧版本浏览器不支持这两个元素 H5之后引入的
不同的浏览器支持的音视频格式可能不一致
mp4, webm 为了兼容性 source 作为子元素 这样读取两个格式  source指定多个可用源
表单元素一系列元素，主要用于收集用户数据
input输入框
type 属性表示不同的输入框类型 
value 输入默认值
placeholder 提示占位信息
]]></content>
  </entry>
  <entry>
    <title>Hexo 初探1：如何添加自己的 JS 文件</title>
    <url>/2025/09/24/1/</url>
    <content><![CDATA[在 Hexo 中添加自己的 JS 文件之前，需要先理解 Hexo 对不同类型文件的处理原理。


Hexo 核心处理逻辑Hexo 对文件的处理总体上分为两类：
1. 渲染（Render）
Hexo 会将源文件转换为 HTML 或其他可输出格式。
通常针对：
Markdown (.md)
EJS (.ejs)
Swig (.swig)
YAML (.yml) 等模板文件


渲染后输出到 public/ 目录，会生成最终的 HTML 页面。

2. 原样复制（Copy）
Hexo 会直接把源文件拷贝到 public/，不会修改内容。
通常针对：
CSS 文件
JS 文件
图片
字体等静态资源


也可以通过 skip_render 配置强制跳过渲染。


⚠️ 注意：JS 文件如果放在 source/ 下，需要配合 skip_render，防止被 Hexo 当作模板渲染，生成 HTML 或纯文本。


Hexo 添加 JS 的解决方案在添加 JS 文件时，需要明确 JS 的类型和用途。
1. 根目录 scripts/script.js（服务端 JS）
放在项目根目录的 scripts/ 下。
Hexo 在每次运行时由 Node.js 执行该脚本。
适合用于扩展 Hexo 功能，例如：
注册 Filter
注册 Generator
注册 Helper


⚠️ 不会直接生成到网站前端。

2. 浏览器端 JS：source/js/script.js
放在 source/ 下，例如 source/js/script.js。
Hexo 会 原样复制 到 public/js/script.js（需配置 skip_render）。
在网页中通过 &lt;script&gt; 标签引用：

&lt;script src=&quot;/js/script.js&quot;&gt;&lt;/script&gt;
全局 JSnext 的全局 JS 的解决方案是 因为每个页面都有 footer 组件 那么我们可以在 footer 组件里面放入一个 script 标签 这样每次都可以运行全局脚本
局部 JS可以在想要的组件里面添加 script 标签

⚠️ 关于 custom_file_path ：这个参数本意是想让你指定 html 文本类直接注入到 index.html 中，倒是也可以添加一些全局 JS 文件，但是请写上 &lt;script&gt; 包裹你的脚本

JS 执行顺序Hexo 核心 JS -&gt; 主题自带 JS -&gt; 第三方插件 JS -&gt; 用户自定义 JS
所以你完全不用担心 JS 执行顺序带来的 bug

⚠️ CSS 同理 JS

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 初探2：hexo s --debug</title>
    <url>/2025/09/25/2/</url>
    <content><![CDATA[Hexo 静态博客Hexo 生成的是静态的 HTML / CSS / JS 文件。当你执行以下命令：

hexo g (generate)hexo s (server)

生成静态文件 将 Markdown、模板文件等必要文件渲染或复制到 public/ 目录下。
启动本地服务器 启动一个 HTTP 服务，返回 public/ 目录下的文件。

每次更改后的处理每次修改内容时，你需要重新向服务器获取文件，而不是热更新。
注意：

hexo s 默认带 —watch，会监控文件变化并重新生成静态文件。

但是浏览器中获取的仍然是上一次生成的内容，因此需要手动刷新以获取最新结果。


—debug 参数不会改变 Hexo 功能，只会打印更多日志，方便调试。
hexo s --debug
这样可以帮助你排查生成或启动服务器时可能出现的问题
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 初探3：Hexo 是基于模板和 yml 配置的</title>
    <url>/2025/09/25/3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>网络概念</title>
    <url>/2025/09/25/4/</url>
    <content><![CDATA[计算机网络基础笔记
OSI 七层模型
物理层
数据链路层
网络层
传输层
会话层
表示层
应用层

TCP/IP 五层协议
物理层
数据链路层
网络层
传输层
应用层


从 URL 到页面展示
浏览器解析 URL
检查浏览器缓存是否存在该资源
DNS 解析域名
建立 TCP 连接（三次握手）
客户端发送 HTTP 请求，服务器返回 HTTP 响应
断开连接（TCP 四次挥手）
浏览器渲染页面并展示


HTTP 请求与响应HTTP 请求报文
请求头：请求方法 (GET, POST, PUT…)、HTTP 版本、资源路径、Content-Type、Cookie 等
请求体：包含请求数据（GET 请求一般没有请求体）

HTTP 响应报文
响应头：HTTP 版本、语言、Content-Type、状态码、状态信息、过期时间、缓存策略、跨域设置等
响应体：实际返回的数据内容


HTTP 方法
GET：获取数据，参数拼接在 URL 后，请求体无数据
POST：提交数据，请求体包含数据


常见 HTTP 状态码
200 OK：请求成功
201 Created：创建了新资源
204 No Content：请求成功但无返回内容
301/302 Redirect：重定向
403 Forbidden：禁止访问
404 Not Found：资源不存在
500 Internal Server Error：服务器内部错误
503 Service Unavailable：服务不可用


缓存策略
强缓存：在资源有效期内，直接从缓存读取，不与服务器通信
协商缓存：强缓存过期后，与服务器确认资源是否更新：
未更新 → 使用缓存
已更新 → 重新获取




HTTP vs HTTPS
HTTP：明文传输，端口 80
HTTPS：基于 SSL/TLS 的加密传输，更安全，端口 443


TCP 与 UDPTCP 特点
面向连接
可靠传输
拥塞控制、流量控制
丢失重传（确认应答 + 超时重传）

TCP 机制
拥塞控制：
慢启动（指数级增长）
达到阈值后线性增长
拥塞发生时，发送窗口减半


流量控制：
接收方控制发送速率
窗口大小动态调整



UDP 特点
无连接，不保证可靠性
丢包不重传，时效性高
常用于直播、语音通话等场景


TCP 三次握手
客户端 → 服务端：SYN
服务端 → 客户端：SYN + ACK
客户端 → 服务端：ACK

👉 目的：保证客户端和服务端都能正常收发数据，通道双向可用。
]]></content>
      <categories>
        <category>前端八股</category>
      </categories>
      <tags>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>React 概念</title>
    <url>/2025/09/26/5/</url>
    <content><![CDATA[不直接操纵 DOM =&gt; React 是声明式的

如何更新组件 view : In React, a view is updated by re-rendering the component. React calls the component function again简单理解： 渲染组件 =&gt; 创建一个新的组件替换原来的组件State is preserved throughout re-renders状态被重置，当组件完全从 UI 中消失，这个叫做取消挂载 卸载 unmounting当 state 更新的时候会触发 re-render 所以当想更新 view 直接更新 stateReact reacts to state changes by re-rendering the UI
const [state, setState] = useState;
React dev tools build react component tree… props,hooks,rendered by,可以任意调试状态
How react work behind the scenes
组件： 是一段 UI 的描述，是一个函数返回 React elements，理解为一个模板组件实例：当我们使用 components 时候创建的实例，是 component 的实际表现，有自己的生命周期(born,live,die)元素：每一个 组件实例 都会返回一个或多个 React.elementex: JSX ——-convert——&gt; React.createElement() function callsA React element is the result of these function callsReact element 是包含所有要创建一个 DOM 元素的必要信息的一种 JS 对象 不直接和 DOM 操作 和 DOM 无关，只是最终为了创建 DOM 的对象React element =&gt; DOM element 最终的视觉效果
]]></content>
      <categories>
        <category>前端八股</category>
      </categories>
      <tags>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hook</title>
    <url>/2025/09/26/6/</url>
    <content><![CDATA[React Hooks 笔记什么是 React Hooks？
Hooks 是 React 提供的 特殊内置函数，让我们可以“钩住” React 的内部机制。它们暴露了部分 React 的内部功能，例如：

创建和访问 Fiber 树中的状态
在 Fiber 树中注册副作用
手动操作 DOM（较少使用）
以及更多能力……

特点：

以 use 开头（如 useState, useEffect），可以与普通函数区分。
方便复用非视觉逻辑：多个 Hook 可以组合成自定义 Hook。
让函数组件拥有状态、在不同生命周期点运行副作用（v16.8 之前只能在 class 组件里实现）。

React 内置近 20 个 Hook：

常用：useState, useEffect, useReducer, useContext, useRef, useCallback, useMemo, useTransition, useDeferredValue
库作者使用：useSyncExternalStore, useInsertionEffect


Hooks 使用规则
只在顶层调用 Hooks

不能放在条件语句、循环、嵌套函数中
不能放在 return 之后
保证 Hooks 的调用顺序始终一致


只在 React 函数中调用 Hooks

✅ 函数组件
✅ 自定义 Hook
❌ 普通函数
❌ class 组件



👉 ESlint 插件会帮我们检测 Hook 使用规则。

Hooks 与调用顺序Hooks 依赖 调用顺序 来绑定状态：

虚拟 DOM → Fiber 树
Fiber 节点有一个 Hooks 链表 (List of hooks)
链表按调用顺序生成和匹配

示例：
const [A, setA] = useState(23);if (A === 23) const [B, setB] = useState(&#x27;&#x27;);useEffect(fnz, []);
]]></content>
      <categories>
        <category>前端八股</category>
      </categories>
      <tags>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>面试算法题</title>
    <url>/2025/09/29/7/</url>
    <content><![CDATA[链表与数组相关算法总结
1. 删除链表中的元素var removeElements = function (head, val) &#123;  let dummy = new ListNode(0, head);  let cur = dummy;  while (cur.next) &#123;    if (cur.next.val === val) &#123;      cur.next = cur.next.next;    &#125; else &#123;      cur = cur.next;    &#125;  &#125;  return dummy.next;&#125;;
2.反转链表var reverseList = function (head) &#123;  if (!head) return null;  let end = head;  while (end.next) end = end.next;  function reverse(node) &#123;    if (node.next === null) &#123;      return node;    &#125; else &#123;      return (reverse(node.next).next = node);    &#125;  &#125;  reverse(head).next = null;  return end;&#125;;
3. 数组去重（双指针法）var removeDuplicates = function (nums) &#123;  let slow = 1;  let fast = 1;  while (fast !== nums.length) &#123;    if (nums[slow - 1] !== nums[fast]) &#123;      nums[slow++] = nums[fast];    &#125; else &#123;      fast++;    &#125;  &#125;  return slow;&#125;;
4. 移除数组中的某个元素var removeElement = function (nums, val) &#123;  let slow = 0;  let fast = 0;  while (fast !== nums.length) &#123;    if (nums[fast] === val) &#123;      fast++;    &#125; else &#123;      nums[slow] = nums[fast];      fast++;      slow++;    &#125;  &#125;  return slow;&#125;;
5. 算法写作原则写好的代码
不要写“恶心”的代码。
当你需要某个功能函数时，如果已有现成实现（AI 或第三方库），就不要重复造轮子。
做开发的目标是 最终产出可维护、可用的代码。


写算法前要想清楚
明确起止条件
明确答案的表现形式（数组、链表、数值等）
从语义上保证代码正确
能够自己推导出逻辑，而不是依赖抄答案


数组抽象思路如果问题可以抽象为“答案数组”：

考虑常规的数组操作（插入、删除、覆盖、移动等）
思考如何根据输入计算出答案


保证代码正确性除了常规情况，还要考虑：

边界值
极端值

确保算法在各种场景下都能正确运行。

算法复杂度选择
数据规模较小 → 可以用暴力算法
数据规模较大 → 必须考虑优化


暴力枚举的思路
枚举就是函数映射： f(x) = y
定义域 (X)： 所有可能的输入（枚举单元）
映射规则 (f)： 输入如何映射到结果
值域 / 解空间 (Y)： 所有可能的答案

目标： 在解空间中找到最符合题目要求的解。
写算法题的时候是用数学归纳法很好用，并且可以分类讨论，不重不漏，奇偶分类之类的很好用
算法要能被数学证明是正确的
很多事情都是没有正确的方法 导致学的非常痛苦 没有提升
任何涉及到数字的比较 JS 都会把他转换为数字类型 比如 undefined 和数字，undefined 转换为数字是 NaN NaN 和任何数字做表达式运算的结果都是 false
JS [].sort 是按照字典顺序 而非数字大小顺序 比如 [1,-2,2,10].sort() =&gt; [-2,1,10,2]
题目要保证某些东西互不相同 那么最好的办法就是把他们做成 map 的 key 去重
JS 字符串是不可变的 无法改变里面的值 s=”string” s[1]=”d” s 依然是”string”
React/框架：每种框架都是一种编程范式，比如 react 是声明式编程，区别于命令式编程
声明式编程：只是描述这里有一个东西是什么样子的，不用关心具体实现
命令式编程：其实就是声明式编程具体的实现，书写每一步要做什么
声明式编程更利于大项目的开发 因为不用关心详细的细节
写小 demo 脚本可以使用命令式编程更好
react 生态丰富 基本上每一个你需要的东西 都可以有现成的第三方工具使用
react 完全可以跨平台开发 [react Native] 学习方式参考资料 AI react 官方文档和教程
react 是一个用于构建网页和原生产品的交互界面的库
库是解决特定类型问题的工具，往往产品的开发除了库还要别的东西集合框架是集合了开发项目所需的所有的库
React 的主要作用是专注于视图层和组件化
视图层：页面中元素管理的代码 View
组件化：设定相应的逻辑就可以批量生产组件，多次重复的调用
虚拟 DOM：React 封装的一层 JS 对象，是 React.createElement 函数调用返回的结果，然后以树的形式组织起来的，里面节点就是 react 元素
所去别的 fiber tree 就是树形链表的形式，又做了一层封装 为了快速的找到 diff 和协调 找到需要提交的 dom 更改 ，给到 commit 阶段
只有真实的 DOM 才会是页面上展示的结果，虚拟 DOM 其实就是为了控制真实的 DOM 可以提高页面的更新效率 为了保证浏览器的性能，短时间内大量多次的重绘有效率问题
但是呢，任何的技术方案都有自己的优缺点，主要还是看适合项目与否
React 开发环境设置： 不用构建工具,codesandbox,vite,cra,next.js
不用构建工具 你要导入两个 script 标签，一个是虚拟 DOM 做出真正的 fiber, 还有一个是和真实 DOM 打交道 commit 阶段,还有一个 babel 从在线地址中导入代码 defer
useEffect / useLayoutEffect 使用方式一模一样，只是生命周期发生的时间点不一样，这两个函数都是在提交阶段生效，在生成真实 DOM 之后，会执行 useLayoutEffect 中注册的回调函数，然后浏览器绘制页面，之后执行 useEffect 中注册的回调函数，注册是在虚拟 DOM 的时候就被注册
之后再次渲染，若依赖数组中有变化，会在 diff 算法之后
先执行 useLayoutEffect 的 return 函数 然后执行 useLayoutEffect 的回调函数
然后在浏览器重新绘制页面之后执行 useEffect 的 return 函数 然后执行 useEffect 的回调函数 [看到真实的结果]
组件生命周期：组件实例从创建到销毁的过程 函数组件实例的生命周期
分别从整体的视角和从组件的视角来查看 react 是如何工作
mount 挂载：组件的第一次执行/渲染
mount 过程: 执行函数组件代码，计算 JSX 生成新虚拟 DOM -&gt; 生成真实 DOM -&gt; useLayoutEffec 过程 -&gt; 浏览器渲染绘制页面 (Repainr/Reflow) -&gt; useEffect 过程
update 更新：组件第 n 次执行/渲染
update 过程： 重新执行函数组件代码，计算 JSX 生成新虚拟 DOM -&gt; Diff &amp; 真实 DOM 更新 -&gt; useLayout 过程 -&gt; 浏览器渲染绘制页面 (Repainr/Reflow) -&gt; useEffect 过程
unmount 卸载：组件从页面上移除
unmount 过程: 标记需要移除的虚拟 DOM -&gt; 移除真实 DOM -&gt; useLayoutEffect -&gt; 浏览器渲染绘制页面 -&gt; useEffect -&gt; 清理并释放虚拟 DOM 等相关数据内存
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>项目相关</title>
    <url>/2025/09/30/8/</url>
    <content><![CDATA[项目必须做 git 版本控制，不然添加一个新的功能，可能会把项目搞崩溃，并不是所有的命令，所有的原理一上来都明白的

但是不要写屎代码，搞明白原理很重要
做 gitignore 有模板，直接找模板就行了
做新功能的时候，如果不知道怎么做，最好的办法就是去查官方文档，官方文档会推荐你怎么做
并且学会检索。可以根据主页检索，你要做哪个主页的功能，就去看哪个页面的配置文件，直接检索就是你要做的功能按照功能分类等方式
按照 URL 分类是一个不错的方式
找不到的时候，再去考虑别的
可以先做官方文档的默认 demo，激活一下 demo，看看能不能用，然后再自定义
添加分页的原理： 当执行 hexo g, hexo 会调用 generator 插件。hexo-generator-index 读取 _config.yml 里的 per_page 参数，把文章组切成 N 份，分别生成对应的 index.html,page/2/index.html …
这些分页信息 page.prev page.next page.total 会渲染到模板的 locals 中
所以配置文件只是给插件提供参数,真正干活的是插件和主题模板
所以前端的各种组件，写的好的包都是在原生 JS 上做包装，没有什么神秘的，比如 router 配件可以在 window.location 上做封装
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
</search>
